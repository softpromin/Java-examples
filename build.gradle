subprojects {
    apply plugin: 'java'

    sourceCompatibility = '1.8'
    targetCompatibility = '1.8'

    repositories {
        mavenLocal()
        mavenCentral()
    }

    sourceSets {
        main {
            java {
                srcDir projectDir
            }
        }
    }

    List tasks = []

    projectDir.eachFileRecurse {
        if (it.name.endsWith('.java')) {

            List lines = it.readLines()

            Boolean hasMainMethod = lines.join('').contains('main(String[] args)')
            Boolean hasMainParam = lines.find { it.startsWith('// {main: ')}
            Boolean willNotCompile = lines.find { it.startsWith('// {CompileTimeError') }
            Boolean validateByHand = lines.find { it.startsWith('// {ValidateByHand}') }

            // add tasks for java sources with main methods
            if ((hasMainMethod || hasMainParam) && (!willNotCompile)) {

                String maybeArgsLine = lines.find { it.startsWith('// {Args: ')}

                List maybeArgs = []
                if (maybeArgsLine != null) {
                    maybeArgs = maybeArgsLine.trim().replaceAll('\\/\\/ \\{Args: ', '').reverse().replaceFirst('}', '').reverse().split(' ')
                }

                String mainClass = it.name.replaceAll('.java', '')

                String taskName = mainClass
                tasks.add(taskName)

                // some java sources with a main method specify a different main class
                String maybeMainLine = lines.find { it.startsWith('// {main: ')}
                if (maybeMainLine != null) {
                    mainClass = maybeMainLine.trim().replaceAll('\\/\\/ \\{main: ', '').replaceAll('}', '')
                }

                // some java sources with JVM args
                List maybeJvmArgs = []
                String maybeJvmArgsLine = lines.find { it.startsWith('// {JVMArgs: ')}
                if (maybeJvmArgsLine != null) {
                    maybeJvmArgs = maybeJvmArgsLine.trim().replaceAll('\\/\\/ \\{JVMArgs: ', '').replaceAll('}', '').split(' ')
                }

                // some java sources depend on others to be run first
                String maybeRunFirst = null
                String maybeRunFirstLine = lines.find { it.startsWith('// {RunFirst: ')}
                if (maybeRunFirstLine != null) {
                    maybeRunFirst = maybeRunFirstLine.trim().replaceAll('\\/\\/ \\{RunFirst: ', '').replaceAll('}', '')
                }

                // some java apps intentionally throw an exception
                Boolean maybeIgnoreExitValue = false
                if (lines.find { it.startsWith('// {ThrowsException}') } != null) {
                    maybeIgnoreExitValue = true
                }

                // some java apps need a timeout
                Boolean timeOutDuringTesting = false
                if (lines.find { it.startsWith('// {TimeOutDuringTesting}') } != null) {
                    timeOutDuringTesting = true
                }

                if (timeOutDuringTesting) {
                    // todo: apps with timeOutDuringTesting need special handling
                    task "$taskName" << {
                        println "not implemented"
                    }

                    task "test$taskName" << {
                        println "not implemented"
                    }
                }
                else {
                    task "$taskName"(type: JavaExec, dependsOn: maybeRunFirst) {
                        main = mainClass
                        classpath = sourceSets.main.runtimeClasspath
                        args = maybeArgs
                        jvmArgs = maybeJvmArgs
                        ignoreExitValue = maybeIgnoreExitValue
                    }

                    Integer expectedOutputStartLine = lines.findIndexOf { it.startsWith('/* Output:') }
                    Integer expectedOutputEndLine = -1
                    List expectedOutputLines = []

                    if (expectedOutputStartLine != -1) {
                        expectedOutputStartLine += 1
                        expectedOutputEndLine = lines.findIndexOf(expectedOutputStartLine, { it.startsWith('*/') })
                        if (expectedOutputEndLine == -1) {
                            expectedOutputEndLine = expectedOutputStartLine
                        }
                        expectedOutputLines = lines.subList(expectedOutputStartLine, expectedOutputEndLine)
                    }

                    OutputStream testStandardOutput = new ByteArrayOutputStream()
                    OutputStream testErrorOutput = new ByteArrayOutputStream()

                    task "test$taskName"(type: JavaExec, dependsOn: maybeRunFirst) {
                        main = mainClass
                        classpath = sourceSets.main.runtimeClasspath
                        args = maybeArgs
                        jvmArgs = maybeJvmArgs
                        ignoreExitValue = maybeIgnoreExitValue
                        standardOutput = testStandardOutput
                        errorOutput = testErrorOutput
                        doLast {
                            // test the output here
                            def rstrip = { it.replaceAll('\\s$', '') }
                            List testStandardOutputLines = testStandardOutput.toString().readLines().collect(rstrip)

                            assert expectedOutputLines.size() == testStandardOutputLines.size()

                            expectedOutputLines.eachWithIndex { expectedLine, i -> assert expectedLine == testStandardOutputLines.get(i) }
                        }
                    }
                }
            }

            // exclude java sources that will not compile
            if (willNotCompile) {
                sourceSets.main.java.excludes.add(it.name)
            }
        }
    }

    task run(dependsOn: tasks)

    List testTasks = tasks.collect { "test" + it }
    task test(overwrite:true, dependsOn: testTasks)
}

configure(subprojects - project(':onjava')) {

    dependencies {
        compile project(':onjava')
    }

}
